package lesson2;

public class HomeWork2 {

    //Задать целочисленный массив, состоящий из элементов 0 и 1. Например: [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 0 ]. С помощью цикла и условия заменить 0 на 1, 1 на 0;
//Задать пустой целочисленный массив размером 8. С помощью цикла заполнить его значениями 0 3 6 9 12 15 18 21;
//Задать массив [ 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 ] пройти по нему циклом, и числа меньшие 6 умножить на 2;
//Создать квадратный двумерный целочисленный массив (количество строк и столбцов одинаковое), и с помощью цикла(-ов) заполнить его диагональные элементы единицами;
//** Задать одномерный массив и найти в нем минимальный и максимальный элементы (без помощи интернета);
//** Написать метод, в который передается не пустой одномерный целочисленный массив, метод должен вернуть true, если в массиве есть место, в котором сумма левой и правой части массива равны. Примеры: checkBalance([2, 2, 2, 1, 2, 2, || 10, 1]) → true, checkBalance([1, 1, 1, || 2, 1]) → true, граница показана символами ||, эти символы в массив не входят.
//**** Написать метод, которому на вход подается одномерный массив и число n (может быть положительным, или отрицательным), при этом метод должен сместить все элементы массива на n позиций. Элементы смещаются циклично. Для усложнения задачи нельзя пользоваться вспомогательными массивами. Примеры: [ 1, 2, 3 ] при n = 1 (на один вправо) -> [ 3, 1, 2 ]; [ 3, 5, 6, 1] при n = -2 (на два влево) -> [ 6, 1, 3, 5 ]. При каком n в какую сторону сдвиг можете выбирать сами.

        public static void main(String[] args) {
            doTask1();
            doTask2();
            doTask3();
            doTask4();
            doTask5();
            doTask6();
            int[] arr = {1, 2, 3, 4, 5, 6};
            doTask7(arr, -9);
        }

        static void printArray(int[] arr) { //
            System.out.println(" ");
            for (int i = 0; i < arr.length; i++) {
                System.out.print(arr[i] + " ");
            }
            System.out.println(" ");
        }

        static void print2DArray(int[][] arr) {
            System.out.println(" ");
            for (int i = 0; i < arr.length; i++) {
                for (int j = 0; j < arr[i].length; j++) {
                    System.out.print(arr[i][j]);
                    System.out.print(" ");
                }
                System.out.println(" ");
            }
        }

        static void doTask1() { // ПЕРВОЕ ЗАДАНИЕ
            int[] arr = {1, 1, 0, 0, 1, 0, 1, 1, 0, 0}; // Задаю исходный массив
            System.out.print("Исходный массив: "); // Вывожу вспомогательное сообщение для читаемости
            printArray(arr); // Использую метод для выведения массива в консоль
            for (int i = 0; i < arr.length; i++) { // Создаю итерацию, которая пробегает по всем элементам массива
                if (arr[i] == 0) { // Создаю условие при котором, если значение в элементе будет равно нулю
                    arr[i] = 1; // То присваиваю этому значению единицу
                } else { // В противном случае
                    arr[i] = 0; // Присваиваю ноль
                }
            }
            System.out.print("Преобразованный массив: "); // --\\--
            printArray(arr);// Вывожу преобразорванный массив
        }

        static void doTask2() { // ВТОРОЕ ЗАДАНИЕ
            int[] arr = new int[8]; // Создаю пустой целочисленный массив, в котором общее количество элементов будет равно восьми
            for (int i = 0; i < arr.length; i++) { // Создаю итерацию которая пробегается по всем элементам массива( в дальнейшем --\\--)
                arr[i] = i * 3; // Присваиваю каждому элементу массива коэффициент 3
            }
            printArray(arr); // Вывожу
        }
        static void doTask3() {
            int[] arr = { 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 };
            System.out.print("Исходный массив: ");
            printArray(arr); // Вывожу исходный массив
            for (int i = 0; i < arr.length; i++) { // --\\--
                if (arr[i] < 6) { // Создаю условие при котором, если значение элемента меньше шести
                    arr[i] = arr[i] * 2; // Присваиваю ему коэффициент 2
                }
            }
            System.out.print("Полученный массив: ");
            printArray(arr); // Вывожу
        }

        static void doTask4() {
            int[][] arr = new int[5][5]; // Создаю двумерный кважратный массив длинной в 5
            for (int i = 0; i < arr.length; i++) { // --\\--
                arr[i][i] = 1; // При каждом равенстве элемента внешнего массива элементу внутреннего массива образуется первая диагональ
                arr[i][arr.length - i - 1] = 1; // Чтобы создать вторую диагональ, то из каждой строчки мне нужно обратиться к последнему элементу минус порядковый номер элемента внешнего массива, так как отсчёт элементов начинается с 0, значит отнимаем ещё одну единицу
            }
            System.out.print("Полученный массив: "); //
            print2DArray(arr); // Вывожу
        }

        static void doTask5() {
            int[] arr = {1, 4, 5, 6, 7, 1, 3, 9, 44, 123, -19}; // Создаю массив
            printArray(arr); // Вывожу исходный массив
            int min = arr[0]; // Создаю перменную, которая будет принимать в себя минимальное значение из массива и присваиваю ему значение первого элемента массива
            int max = arr[0]; // Создаю переменную которая будет принимать в себя максимальное значение из массива и присваиваю ему значение первого элемента массива
            for (int i = 0; i < arr.length; i++) { // --\\--
                if (min > arr[i]){ // Если содержимое в переменной будет больше, чем элемент массива
                    min = arr[i]; // То присваиваю ему значение элемента массива
                } else if (max < arr[i]){ // Если содержимое в переменной будет меньше, чем элемент массива
                    max = arr[i]; // Присваиваю ему значение элемента массива
                }
            }
            System.out.println("Минимальное значение в массиве : " + min);// Вывожу минимальное значение
            System.out.println("Максимальное значение в массиве: " + max);// Вывожу максимальное значение
        }

        static void doTask6() {
            int[] arr = {2, 2, 2, 1, 2, 2, 10, 1}; // Создаю массив
            int arraySum = 0; // Создаю переменную которая будет содержать в себе сумму всех элментов массива
            int leftSum = 0; // Создаю переменную которая будет содержать в себе сумму элементов слева направо, но буду использовать этот счётчик на каждом шаге итерации
            boolean balance = false; // Создаю переменную и присваиваю ей дефолтное фолсовое значение
            for (int i = 0; i < arr.length; i++) { // --\\--
                arraySum += arr[i]; // Считаю сумму всех элементов
            }
            for (int i = 0; i < arr.length; i++) { // --\\--
                leftSum += arr[i]; // Присваиваю переменной сумму элементов слева направо
                if (leftSum == arraySum - leftSum) { // Создаю условие если сумма слева равна остатку справа
                    balance = true; // То присваиваю переменной баланса тру
                    break; // И завершаю итерацию
                }
            }
            System.out.println(balance); // Вывожу
        }

        static void doTask7(int[]arr, int n) {
            int aL = arr.length; // Создаю переменную для более легкого написания значения длины массива
            n = n % aL; // Нахожу модуль числа n для избежания лишних циклов при большом значении n
            if (n > 0) { // Если n больше нуля, значит будем двигать массив вправо
                for (int j = 1; j <= n; j++) { // Создаю итерацию которая отвечает за количество повторов единичных сдвигов
                    int tmp = arr[aL - 1]; // Создаю временную переменную в которую помещая значение последнего элемнта массива
                    for (int i = aL - 1; i > 0; i--) { // Создаю итерацию в которой сдвиг начну с конца, дабы избежать значения первого элемента во всех ячейках
                        arr[i] = arr[i - 1]; // Присваю каждому элементу значение предыдущего в массива элемента
                    }
                    arr[0] = tmp; // Присваиваю первому элементу изначальное значение последнего элемента
                }
            }
            if (n < 0) { // Если n будет отрицательным, значит будем сдвигать влево
                n = n * (-1); // Делаю n положительным числом для облегчения отсчёта
                for (int j = 1; j <= n; j++) { // Создаю итерацию которая отвечает за количество повторов единичных сдвигов
                    int tmp = arr[0]; // Создаю временную переменную в которую помещаю значение первого элемента массива
                    for (int i = 0; i < arr.length - 1; i++) { // Создаю итерацию, которая обращается ко всем элементам массива слева направо за исключением последнего элемента
                        arr[i] = arr[i + 1]; // Присваиваю каждому элементу значение элемента который стоит впереди
                    } arr[aL - 1] = tmp; // Присваиваю последнему элементу изначальное значение первого элемента
                }
            }
            printArray(arr); // Вывожу преобразованный массив
        }



    }
